#+hugo_base_dir: /home/phihungnguyen/blog/secondbrain
* Query Gate 3
:PROPERTIES:
:EXPORT_FILE_NAME: query_model3
:ID:       37409b01-071d-4cca-b3bb-7ba1b46845e8la
:END:
#+title: query

The computational model is usually built as
[[id:9aef3386-da89-40f4-baae-76c05b109a3c][Deutsch's Problem]]
input -> computation -> output

For query model, the input is not provided to the computation.
The input is a function that the computation acceses by making queries.
(random access to the input)

input
|
computation ---> output

Since the input is hidden (oracle/blackbox), only by asking the information of
the input could be revealed.

For a funcion $f: \sum^n-> \sum^m$.
When the query $x\in \sum^n$ is made by a computation, a value $f(x) \in \sum^m$
is made available.

Efficiency of query algorithms: the number of queries made.

Examples:

** OR
$f: \sum^n -> \sum$

Output 1 if there exists string $x\in\sum^n$ for which $f(x)=1$
Output 0 if there is no string like that/

** Parity
$f: \sum^n -> \sum$
The goal is to determine if it is even or odd
0 if the set $\{x \in \sum^n: f(x)=1\}$ has an even number of elements
1 otherwise

** Minimum
$f: \sum^n -> \sum^m$
compute the minimum of the intergers


Sometimes, we also have a promise on the input (some types of guarantee)
For example

unique Search:
we guarante that there is only one for which $f(x)=1$

